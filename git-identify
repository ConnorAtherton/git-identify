#!/bin/bash

# fail if unset vars
set -ue

# fail if globs aren't expanded
# shopt -s failglob

# git-identify
#
# - Directory matches are case sensitive
# - Comments are lines starting with '//'
# - Globs must start with from the root directory or
#   from the home directory.

# Reolving iddenties is greedy. It will pick the first
# match for a patten regardless if it is used in an
# identity later on

# The location of the file holding the identities
IDENTITIES_FILE="${GIT_IDENTITIES:-$HOME/.git_identities}"

# Final identities are stored in this form
#
# <identity_name>:email=<email>,name=<name>
# <identity_name>:email=<email>,name=<name>
#
# This way we can add more attributes in the future if
# we want too.
IDENTITIES_LIST=()

# Are we filling in an identity or not
CHECKING_CURRENT_IDENTITY=0

# The name of the current identity
CURRENT_IDENTITY=""

# List of checked attributes. Strings seperated by a string.
CURRENT_IDENTITY_ATTRIBUTES=""

# The representation of an identity string: a combination of the
# identity name with all of it's attributes
CURRENT_IDENTITY_STRING=""

# Store this for later so we don't have to keep in subshells
CURRENT_DIRECTORY=$(pwd)

identity_contains() {
  for key in $@; do
    if [[ ! $CURRENT_IDENTITY_ATTRIBUTES =~ $key ]]; then
      # return as soon as we know one of the keys are missing
      return 1
    fi
  done

  echo "We have both keys now"
  return 0
}

current_identity_full() {
  identity_contains "email" "name" >/dev/null
  return $?
}

error_if_parsing_identity() {
  if [[ "$CHECKING_CURRENT_IDENTITY" = 1 ]]; then
    error "Malformed .git_identities file: Have you specified a name and a username for each identity?"
  fi
}

matches_current_directory() {
  for file in "$1"; do
    echo "Checking $CURRENT_DIRECTORY == $file"
    # NOTE: using [[ ]] for the second condition because [ ]
    # doesn't allow regular expression expansion.
    if [ -e "$file" ] && [[ $file == $CURRENT_DIRECTORY ]]; then
      return 0
    fi
  done

  return 1
}

match_identities() {
  # check if the file exists
  if [[ ! -f $IDENTITIES_FILE ]]; then
    error "Add a ~/.git_identities file"
  fi

  while IFS='' read -r line || [[ -n "$line" ]]; do
    local identity_name=

    # trim whitespace
    line=$(echo $line | sed -e 's/[[:blank:]]//g')

    # comment or empty line
    if [[ "$line" =~ ^\/\/.*$ ]] || [[ -z "$line" ]]; then continue; fi

    # echo "> $line"

    # [identity:name]
    if [[ "$line" =~ ^\[identity:[a-z]*\]$ ]]; then
      error_if_parsing_identity

      CURRENT_IDENTITY=$(echo $line | sed -e 's/\[identity:\([a-z]*\)\]/\1/')
      CURRENT_IDENTITY_STRING+="$CURRENT_IDENTITY:"
      continue
    fi

    # attr=value
    if [[ "$line" =~ ^(name|email)=(.*)$ ]]; then
      local key=$(echo "$line" | awk -F "=" '{ print $1 }')

      # duplicated entry for any of the keys
      if identity_contains "$key"; then
        error "Duplicated key $key for identity $CURRENT_IDENTITY"
      fi

      # push the key to the current identities attributes
      CURRENT_IDENTITY_ATTRIBUTES+="$key "
      CURRENT_IDENTITY_STRING+="$line,"

      # If we have collected both the name and the email here then we
      # are done with this identity
      if current_identity_full; then
        IDENTITIES_LIST+=( ${CURRENT_IDENTITY_STRING/%?/} )

        # reset everything
        CHECKING_CURRENT_IDENTITY=0
        CURRENT_IDENTITY_ATTRIBUTES=""
        CURRENT_IDENTITY_STRING=""
        CURRENT_IDENTITY=""
      else
        CHECKING_CURRENT_IDENTITY=1
      fi

      continue
    fi

    # [identity_name]
    if [[ "$line" =~ ^\[[a-z]*\]$ ]]; then
      error_if_parsing_identity
      CURRENT_IDENTITY=$(echo $line | sed -e 's/\[\([a-z]*\)\]/\1/')
      continue
    fi

    # /path/to/dir
    if [[ "$line" =~ ^([~|/].*)$ ]]; then
      # We can short circuit if we find the correct path
      # We expand ~ using readlink
      match=$(echo "$line" | sed -e 's/^\(.*\)$/\1/g')
      echo "matching a path $match"
      if matches_current_directory $match; then
        echo "we have a match!!!!!"
      fi
    fi

    # No match if we are here
  done < "$IDENTITIES_FILE"
}

match_identity() {
  echo "matching identity here"
}

error() {
  >&2 echo "${1:-'git-identity error'}"
  exit ${2:1}
}

#
# Main
#
match_identities
